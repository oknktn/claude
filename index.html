
<invoke name="artifacts">
<parameter name="command">create</parameter>
<parameter name="type">text/html</parameter>
<parameter name="id">mobile_tower_defense</parameter>
<parameter name="title">Crystal Defenders - Mobil Tower Defense</parameter>
<parameter name="content"><!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Crystal Defenders - Tower Defense</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 100vw;
      height: 100vh;
      position: relative;
    }

    /* Header */
    .game-header {
      background: rgba(0, 0, 0, 0.5);
      padding: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      backdrop-filter: blur(10px);
      border-bottom: 2px solid rgba(0, 255, 255, 0.3);
      flex-shrink: 0;
    }

    .stat {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 16px;
      font-weight: bold;
    }

    .stat-icon {
      font-size: 20px;
    }

    .header-left, .header-right {
      display: flex;
      gap: 15px;
    }

    .wave-info {
      text-align: center;
      font-size: 14px;
    }

    .wave-number {
      font-size: 18px;
      font-weight: bold;
      color: #00ffff;
    }

    /* Canvas */
    #game-canvas {
      flex: 1;
      background: #0f3460;
      position: relative;
      touch-action: none;
      cursor: crosshair;
    }

    /* Tower Menu */
    .tower-menu {
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      padding: 15px;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      border-top: 2px solid rgba(0, 255, 255, 0.3);
      flex-shrink: 0;
    }

    .tower-btn {
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      border: 2px solid rgba(0, 255, 255, 0.5);
      border-radius: 12px;
      padding: 12px 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      position: relative;
      min-height: 85px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .tower-btn:active {
      transform: scale(0.95);
    }

    .tower-btn.selected {
      background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
      border-color: #00ffff;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
    }

    .tower-btn.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .tower-icon {
      font-size: 28px;
      margin-bottom: 5px;
    }

    .tower-name {
      font-size: 11px;
      font-weight: bold;
      margin-bottom: 3px;
    }

    .tower-cost {
      font-size: 12px;
      color: #ffd700;
      font-weight: bold;
    }

    .tower-stats {
      font-size: 9px;
      color: rgba(255, 255, 255, 0.7);
      margin-top: 3px;
    }

    /* Control Buttons */
    .controls {
      display: flex;
      gap: 8px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      justify-content: center;
      flex-shrink: 0;
    }

    .control-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      border-radius: 10px;
      padding: 12px 20px;
      color: white;
      font-weight: bold;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 5px;
      flex: 1;
      justify-content: center;
      max-width: 150px;
    }

    .control-btn:active {
      transform: scale(0.95);
    }

    .control-btn.start {
      background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
    }

    .control-btn.pause {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      border-radius: 20px;
      padding: 30px;
      max-width: 90%;
      width: 400px;
      text-align: center;
      border: 3px solid rgba(0, 255, 255, 0.5);
    }

    .modal-content h2 {
      font-size: 32px;
      margin-bottom: 15px;
      color: #00ffff;
    }

    .modal-content p {
      font-size: 18px;
      margin-bottom: 25px;
      opacity: 0.9;
    }

    .modal-btn {
      background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
      border: none;
      border-radius: 12px;
      padding: 15px 30px;
      color: white;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
      margin: 5px;
    }

    /* Tooltip */
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #00ffff;
      border-radius: 8px;
      padding: 10px;
      font-size: 12px;
      pointer-events: none;
      z-index: 100;
      display: none;
      max-width: 200px;
    }

    /* Health Bar */
    .enemy-health {
      position: absolute;
      height: 4px;
      background: #ff0000;
      border-radius: 2px;
      transition: width 0.2s ease;
    }

    /* Range indicator */
    .range-indicator {
      position: absolute;
      border: 2px dashed rgba(0, 255, 255, 0.5);
      border-radius: 50%;
      pointer-events: none;
      display: none;
    }

    @media (max-width: 768px) {
      .tower-menu {
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
        padding: 10px;
      }

      .tower-btn {
        padding: 10px 5px;
        min-height: 75px;
      }

      .tower-icon {
        font-size: 24px;
      }

      .tower-name {
        font-size: 10px;
      }

      .tower-cost {
        font-size: 11px;
      }

      .stat {
        font-size: 14px;
      }
    }

    @media (max-width: 480px) {
      .header-left, .header-right {
        gap: 10px;
      }

      .wave-info {
        font-size: 12px;
      }

      .control-btn {
        padding: 10px 15px;
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div class="game-header">
      <div class="header-left">
        <div class="stat">
          <span class="stat-icon">üí∞</span>
          <span id="gold">500</span>
        </div>
        <div class="stat">
          <span class="stat-icon">‚ù§Ô∏è</span>
          <span id="lives">20</span>
        </div>
      </div>
      <div class="wave-info">
        <div class="wave-number" id="wave">Dalga 1</div>
        <div style="font-size: 11px; opacity: 0.8;">D√º≈üman: <span id="enemyCount">0</span></div>
      </div>
      <div class="header-right">
        <div class="stat">
          <span class="stat-icon">üéØ</span>
          <span id="score">0</span>
        </div>
      </div>
    </div>

    <canvas id="game-canvas"></canvas>

    <div class="tower-menu">
      <div class="tower-btn" data-tower="arrow">
        <div class="tower-icon">üèπ</div>
        <div class="tower-name">Ok Kulesi</div>
        <div class="tower-cost">üí∞100</div>
        <div class="tower-stats">Hasar: 10 | Menzil: Orta</div>
      </div>
      <div class="tower-btn" data-tower="cannon">
        <div class="tower-icon">üí£</div>
        <div class="tower-name">Top</div>
        <div class="tower-cost">üí∞200</div>
        <div class="tower-stats">Hasar: 30 | Alan Hasarƒ±</div>
      </div>
      <div class="tower-btn" data-tower="magic">
        <div class="tower-icon">üîÆ</div>
        <div class="tower-name">B√ºy√º</div>
        <div class="tower-cost">üí∞150</div>
        <div class="tower-stats">Hasar: 15 | Yava≈ülatma</div>
      </div>
      <div class="tower-btn" data-tower="ice">
        <div class="tower-icon">‚ùÑÔ∏è</div>
        <div class="tower-name">Buz</div>
        <div class="tower-cost">üí∞250</div>
        <div class="tower-stats">Hasar: 20 | Donma</div>
      </div>
    </div>

    <div class="controls">
      <button class="control-btn start" id="startWave">
        ‚ñ∂Ô∏è Dalgayƒ± Ba≈ülat
      </button>
      <button class="control-btn pause" id="pauseBtn">
        ‚è∏Ô∏è Duraklat
      </button>
      <button class="control-btn" id="sellBtn">
        üí∏ Sat (50%)
      </button>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <div class="modal" id="gameOverModal">
    <div class="modal-content">
      <h2 id="modalTitle">üéÆ</h2>
      <p id="modalText"></p>
      <button class="modal-btn" onclick="location.reload()">Tekrar Oyna</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');

    // Canvas boyutlandƒ±rma
    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Oyun durumu
    const game = {
      gold: 500,
      lives: 20,
      wave: 1,
      score: 0,
      paused: false,
      waveActive: false,
      selectedTower: null,
      selectedTowerObj: null,
      towers: [],
      enemies: [],
      projectiles: [],
      particles: []
    };

    // Yol tanƒ±mƒ± (zig-zag pattern)
    const path = [
      { x: 0, y: 150 },
      { x: 200, y: 150 },
      { x: 200, y: 300 },
      { x: 400, y: 300 },
      { x: 400, y: 150 },
      { x: canvas.width, y: 150 }
    ];

    // Kule tipleri
    const TOWER_TYPES = {
      arrow: {
        cost: 100,
        damage: 10,
        range: 100,
        fireRate: 1000,
        color: '#8B4513',
        projectileColor: '#FFD700',
        icon: 'üèπ'
      },
      cannon: {
        cost: 200,
        damage: 30,
        range: 120,
        fireRate: 2000,
        color: '#696969',
        projectileColor: '#FF4500',
        splash: 50,
        icon: 'üí£'
      },
      magic: {
        cost: 150,
        damage: 15,
        range: 90,
        fireRate: 800,
        color: '#9370DB',
        projectileColor: '#FF00FF',
        slow: 0.5,
        icon: 'üîÆ'
      },
      ice: {
        cost: 250,
        damage: 20,
        range: 110,
        fireRate: 1500,
        color: '#87CEEB',
        projectileColor: '#00FFFF',
        freeze: 2000,
        icon: '‚ùÑÔ∏è'
      }
    };

    // D√º≈üman tipleri
    const ENEMY_TYPES = {
      basic: { hp: 50, speed: 1, gold: 10, color: '#FF6B6B', size: 12, icon: 'üëæ' },
      fast: { hp: 30, speed: 2, gold: 15, color: '#4ECDC4', size: 10, icon: '‚ö°' },
      tank: { hp: 150, speed: 0.6, gold: 30, color: '#95E1D3', size: 16, icon: 'üõ°Ô∏è' },
      boss: { hp: 500, speed: 0.5, gold: 100, color: '#F38181', size: 20, icon: 'üëπ' }
    };

    // D√º≈üman sƒ±nƒ±fƒ±
    class Enemy {
      constructor(type, waveMultiplier) {
        const enemyData = ENEMY_TYPES[type];
        this.type = type;
        this.maxHp = enemyData.hp * waveMultiplier;
        this.hp = this.maxHp;
        this.speed = enemyData.speed;
        this.gold = Math.floor(enemyData.gold * waveMultiplier);
        this.color = enemyData.color;
        this.size = enemyData.size;
        this.icon = enemyData.icon;
        this.pathIndex = 0;
        this.x = path[0].x;
        this.y = path[0].y;
        this.frozen = 0;
        this.slowed = 1;
      }

      update(deltaTime) {
        if (this.frozen > 0) {
          this.frozen -= deltaTime;
          return;
        }

        const target = path[this.pathIndex + 1];
        if (!target) {
          game.lives--;
          updateStats();
          const index = game.enemies.indexOf(this);
          if (index > -1) game.enemies.splice(index, 1);
          
          if (game.lives <= 0) {
            gameOver(false);
          }
          return;
        }

        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 5) {
          this.pathIndex++;
        } else {
          const actualSpeed = this.speed * this.slowed * (deltaTime / 16);
          this.x += (dx / dist) * actualSpeed;
          this.y += (dy / dist) * actualSpeed;
        }

        this.slowed = Math.min(this.slowed + 0.02, 1);
      }

      draw() {
        // D√º≈üman g√∂vdesi
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();

        // ƒ∞kon
        ctx.font = `${this.size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.icon, this.x, this.y);

        // Can √ßubuƒüu
        const barWidth = this.size * 2;
        const barHeight = 4;
        const barX = this.x - barWidth / 2;
        const barY = this.y - this.size - 8;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        const hpPercent = this.hp / this.maxHp;
        ctx.fillStyle = hpPercent > 0.5 ? '#00ff00' : hpPercent > 0.25 ? '#ffff00' : '#ff0000';
        ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);

        // Donma efekti
        if (this.frozen > 0) {
          ctx.strokeStyle = '#00FFFF';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size + 3, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      takeDamage(damage) {
        this.hp -= damage;
        if (this.hp <= 0) {
          game.gold += this.gold;
          game.score += this.gold * 10;
          updateStats();
          
          // Patlama partik√ºl√º
          for (let i = 0; i < 8; i++) {
            game.particles.push({
              x: this.x,
              y: this.y,
              vx: (Math.random() - 0.5) * 4,
              vy: (Math.random() - 0.5) * 4,
              life: 30,
              color: this.color
            });
          }
          
          const index = game.enemies.indexOf(this);
          if (index > -1) game.enemies.splice(index, 1);
        }
      }
    }

    // Kule sƒ±nƒ±fƒ±
    class Tower {
      constructor(type, x, y) {
        this.type = type;
        this.x = x;
        this.y = y;
        this.data = TOWER_TYPES[type];
        this.lastFire = 0;
        this.target = null;
        this.level = 1;
      }

      update(time) {
        // Hedef bul
        this.target = null;
        let closestDist = this.data.range;

        for (const enemy of game.enemies) {
          const dx = enemy.x - this.x;
          const dy = enemy.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < closestDist) {
            closestDist = dist;
            this.target = enemy;
          }
        }

        // Ate≈ü et
        if (this.target && time - this.lastFire > this.data.fireRate) {
          this.fire();
          this.lastFire = time;
        }
      }

      fire() {
        game.projectiles.push({
          x: this.x,
          y: this.y,
          target: this.target,
          speed: 5,
          damage: this.data.damage * this.level,
          color: this.data.projectileColor,
          tower: this
        });
      }

      draw() {
        // Kule g√∂vdesi
        ctx.fillStyle = this.data.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
        ctx.fill();

        // ƒ∞kon
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.data.icon, this.x, this.y);

        // Seviye g√∂stergesi
        if (this.level > 1) {
          ctx.fillStyle = '#FFD700';
          ctx.font = 'bold 10px Arial';
          ctx.fillText(this.level, this.x, this.y + 20);
        }

        // Menzil g√∂stergesi (se√ßiliyse)
        if (game.selectedTowerObj === this) {
          ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.data.range, 0, Math.PI * 2);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Hedef √ßizgisi
        if (this.target) {
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.lineTo(this.target.x, this.target.y);
          ctx.stroke();
        }
      }
    }

    // Yolu √ßiz
    function drawPath() {
      ctx.strokeStyle = 'rgba(139, 69, 19, 0.5)';
      ctx.lineWidth = 40;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(path[0].x, path[0].y);
      for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x, path[i].y);
      }
      ctx.stroke();

      // Yol kenarlarƒ±
      ctx.strokeStyle = 'rgba(101, 67, 33, 0.8)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // Dalga ba≈ülat
    function startWave() {
      if (game.waveActive) return;
      
      game.waveActive = true;
      const waveMultiplier = 1 + (game.wave - 1) * 0.3;
      let enemyCount = 5 + game.wave * 2;

      // Dalga kompozisyonu
      const composition = [];
      const basicCount = Math.floor(enemyCount * 0.5);
      const fastCount = Math.floor(enemyCount * 0.3);
      const tankCount = Math.floor(enemyCount * 0.15);
      const bossCount = game.wave % 5 === 0 ? 1 : 0;

      for (let i = 0; i < basicCount; i++) composition.push('basic');
      for (let i = 0; i < fastCount; i++) composition.push('fast');
      for (let i = 0; i < tankCount; i++) composition.push('tank');
      for (let i = 0; i < bossCount; i++) composition.push('boss');

      // D√º≈ümanlarƒ± spawn et
      let spawnIndex = 0;
      const spawnInterval = setInterval(() => {
        if (spawnIndex >= composition.length) {
          clearInterval(spawnInterval);
          return;
        }

        game.enemies.push(new Enemy(composition[spawnIndex], waveMultiplier));
        spawnIndex++;
      }, 1000);
    }

    // Mermi g√ºncelleme
    function updateProjectiles() {
      for (let i = game.projectiles.length - 1; i >= 0; i--) {
        const proj = game.projectiles[i];
        
        if (!proj.target || proj.target.hp <= 0) {
          game.projectiles.splice(i, 1);
          continue;
        }

        const dx = proj.target.x - proj.x;
        const dy = proj.target.y - proj.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 5) {
          // Hasar ver
          proj.target.takeDamage(proj.damage);

          // √ñzel efektler
          if (proj.tower.data.splash) {
            // Alan hasarƒ±
            game.enemies.forEach(enemy => {
              const edx = enemy.x - proj.target.x;
              const edy = enemy.y - proj.target.y;
              const edist = Math.sqrt(edx * edx + edy * edy);
              if (edist < proj.tower.data.splash) {
                enemy.takeDamage(proj.damage * 0.5);
              }
            });
          }

          if (proj.tower.data.slow) {
            proj.target.slowed = proj.tower.data.slow;
          }

          if (proj.tower.data.freeze) {
            proj.target.frozen = proj.tower.data.freeze;
          }

          game.projectiles.splice(i, 1);
        } else {
          proj.x += (dx / dist) * proj.speed;
          proj.y += (dy / dist) * proj.speed;
        }
      }
    }

    // Partik√ºl g√ºncelleme
    function updateParticles() {
      for (let i = game.particles.length - 1; i >= 0; i--) {
        const p = game.particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;

        if (p.life <= 0) {
          game.particles.splice(i, 1);
        }
      }
    }

    // √áizim
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Arka plan grid
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
      ctx.lineWidth = 1;
      for (let x = 0; x < canvas.width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      drawPath();

      // Kuleler
      game.towers.forEach(tower => tower.draw());

      // D√º≈ümanlar
      game.enemies.forEach(enemy => enemy.draw());

      // Mermiler
      game.projectiles.forEach(proj => {
        ctx.fillStyle = proj.color;
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });

      // Partik√ºl ler
      game.particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 30;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      });
    }

    // G√ºncelleme
    let lastTime = 0;
    function gameLoop(currentTime) {
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;

      if (!game.paused) {
        game.enemies.forEach(enemy => enemy.update(deltaTime));
        game.towers.forEach(tower => tower.update(currentTime));
        updateProjectiles();
        updateParticles();

        // Dalga kontrol√º
        if (game.waveActive && game.enemies.length === 0) {
          game.waveActive = false;
          game.wave++;
          game.gold += 50 + game.wave * 10;
          updateStats();
          
          if (game.wave > 20) {
            gameOver(true);
            return;
          }
        }
      }

      draw();
      requestAnimationFrame(gameLoop);
    }

    // ƒ∞statistikleri g√ºncelle
    function updateStats() {
      document.getElementById('gold').textContent = game.gold;
      document.getElementById('lives').textContent = game.lives;
      document.getElementById('wave').textContent = `Dalga ${game.wave}`;
      document.getElementById('score').textContent = game.score;
      document.getElementById('enemyCount').textContent = game.enemies.length;

      // Kule butonlarƒ±nƒ± g√ºncelle
      document.querySelectorAll('.tower-btn').forEach(btn => {
        const towerType = btn.dataset.tower;
        if (towerType) {
          const cost = TOWER_TYPES[towerType].cost;
          if (game.gold < cost) {
            btn.classList.add('disabled');
          } else {
            btn.classList.remove('disabled');
          }
        }

           });
    }

    // Oyun sonu
    function gameOver(won) {
      game.paused = true;
      const modal = document.getElementById('gameOverModal');
      document.getElementById('modalTitle').textContent = won ? 'üéâ Kazandƒ±nƒ±z!' : 'üíî Oyun Bitti';
      document.getElementById('modalText').textContent = 
        won 
          ? `T√ºm dalgalarƒ± savu≈üturdunuz!\n\nSkor: ${game.score}\nDalga: ${game.wave}`
          : `≈ûehir d√º≈üt√º!\n\nSkor: ${game.score}\nDalga: ${game.wave}`;
      modal.classList.add('active');
    }

    // Event listener'lar
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Kule tƒ±klama kontrol√º
      let towerClicked = false;
      for (const tower of game.towers) {
        const dx = tower.x - x;
        const dy = tower.y - y;
        if (Math.sqrt(dx * dx + dy * dy) < 20) {
          game.selectedTowerObj = tower;
          towerClicked = true;
          draw();
          return;
        }
      }

      // Yeni kule yerle≈ütir
      if (game.selectedTower && !towerClicked) {
        const towerData = TOWER_TYPES[game.selectedTower];
        
        // Yol kontrol√º
        let onPath = false;
        for (let i = 0; i < path.length - 1; i++) {
          const p1 = path[i];
          const p2 = path[i + 1];
          const distToLine = Math.abs((p2.y - p1.y) * x - (p2.x - p1.x) * y + p2.x * p1.y - p2.y * p1.x) / 
                            Math.sqrt((p2.y - p1.y) ** 2 + (p2.x - p1.x) ** 2);
          if (distToLine < 30) {
            onPath = true;
            break;
          }
        }

        if (onPath) {
          alert('Kuleyi yola koyamazsƒ±nƒ±z!');
          return;
        }

        // Kule √ßakƒ±≈üma kontrol√º
        for (const tower of game.towers) {
          const dx = tower.x - x;
          const dy = tower.y - y;
          if (Math.sqrt(dx * dx + dy * dy) < 40) {
            alert('√áok yakƒ±n! Ba≈üka bir yer se√ßin.');
            return;
          }
        }

        if (game.gold >= towerData.cost) {
          game.gold -= towerData.cost;
          game.towers.push(new Tower(game.selectedTower, x, y));
          updateStats();
        }
      }
    });

    // Mobil dokunma desteƒüi
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent('click', {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      canvas.dispatchEvent(mouseEvent);
    });

    // Kule se√ßimi
    document.querySelectorAll('.tower-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const towerType = btn.dataset.tower;
        if (!towerType) return;

        if (game.gold >= TOWER_TYPES[towerType].cost) {
          document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
          game.selectedTower = towerType;
          game.selectedTowerObj = null;
        }
      });
    });

    // Kontrol butonlarƒ±
    document.getElementById('startWave').addEventListener('click', startWave);
    
    document.getElementById('pauseBtn').addEventListener('click', () => {
      game.paused = !game.paused;
      document.getElementById('pauseBtn').innerHTML = game.paused ? '‚ñ∂Ô∏è Devam' : '‚è∏Ô∏è Duraklat';
    });

    document.getElementById('sellBtn').addEventListener('click', () => {
      if (game.selectedTowerObj) {
        const refund = Math.floor(game.selectedTowerObj.data.cost * game.selectedTowerObj.level * 0.5);
        game.gold += refund;
        const index = game.towers.indexOf(game.selectedTowerObj);
        if (index > -1) game.towers.splice(index, 1);
        game.selectedTowerObj = null;
        updateStats();
        draw();
      }
    });

    // Ba≈ülat
    updateStats();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html></parameter>
</invoke>                                           
